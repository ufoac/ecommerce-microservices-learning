## 场景 1：用户注册与登录
**业务流程**：  
用户注册 → 用户登录 → 获取 JWT 令牌

**验收标准**：  

+ 新用户能成功注册账号  
+ 注册信息校验（用户名唯一性、邮箱格式合法性）  
+ 密码使用 BCrypt 加密存储  
+ 登录成功返回 JWT 令牌  
+ 令牌可用于后续接口的身份认证（通过 Feign 或 REST 调用透传）

**学习目标**：  

+ 掌握基于 JWT 的无状态认证机制  
+ 理解微服务间如何透传用户身份（Feign 拦截器）  
+ 实践密码安全存储（BCrypt）与参数校验（Bean Validation）

**业务/技术注意点**：  

+ 初期跳过真实邮箱验证，注册即激活（避免引入 SMTP 依赖）  
+ JWT 令牌应包含 `userId`、`exp` 等必要声明，便于下游服务解析  
+ 在 `common` 模块中提供 `@CurrentUser` 注解，简化 Controller 层用户 ID 获取  
+ Feign 客户端调用时，需通过 `RequestInterceptor` 自动携带 Authorization 头

---

## 场景 2：商品浏览与搜索
**业务流程**：  
浏览商品列表 → 查看商品详情 → 搜索商品 → 按分类筛选

**验收标准**：  

+ 商品列表支持分页展示  
+ 商品详情包含名称、价格、库存、描述、图片等完整信息  
+ 搜索功能根据关键词返回相关商品  
+ 分类筛选能准确过滤结果  
+ 商品数据来自 `product-service`，详情页集成 Redis 缓存

**学习目标**：  

+ 掌握高并发读场景下的缓存设计（Cache-Aside 模式）  
+ 理解缓存穿透、击穿、雪崩的防护策略  
+ 实践分页查询与简单搜索（LIKE 或全文检索简化版）

**业务/技术注意点**：  

+ 商品详情优先查 Redis，未命中再查 DB，并回写缓存  
+ 对空结果也缓存（如 `"empty:1001"`），防止缓存穿透  
+ 设置缓存过期时间时加随机偏移（如 30±5 分钟），避免雪崩  
+ 搜索和分类使用 MyBatis-Plus 的 `QueryWrapper` 实现，不引入 Elasticsearch

---

## 场景 3：购物车管理
**业务流程**：  
添加商品到购物车 → 查看购物车 → 修改商品数量 → 删除商品

**验收标准**：  

+ 未登录用户无法操作购物车（需携带有效 JWT）  
+ 购物车中商品数量与用户操作一致  
+ 修改数量后实时更新总价和库存校验  
+ 删除商品后购物车立即刷新  
+ 购物车数据持久化存储（推荐 Redis Hash，支持 TTL）

**学习目标**：  

+ 理解“临时状态”的存储与管理（非订单，但需持久化）  
+ 实践 DDD 聚合根设计（`Cart` 聚合包含多个 `CartItem`）  
+ 掌握 Redis Hash 结构在购物车场景的应用

**业务/技术注意点**：  

+ 购物车归属用户，Key 设计为 `cart:{userId}`  
+ 添加商品时需调用 `product-service` 校验商品是否存在、是否上架  
+ 修改数量时需校验库存是否充足（防止恶意修改）  
+ 购物车数据不存 MySQL（初期），用 Redis + TTL（如 30 天）即可

---

## 场景 4：订单创建与库存预占
**业务流程**：  
从购物车选择商品 → 创建订单 → 预占库存 → 生成订单号

**验收标准**：  

+ 订单包含用户 ID、商品列表、单价、总价、收货地址等完整信息  
+ 调用 `product-service` 预占库存，防止超卖  
+ 订单号全局唯一，符合业务规则（如时间戳 + 序列）  
+ 订单初始状态为“待支付”  
+ 预占成功后，商品可售库存减少（但未最终扣减）

**学习目标**：  

+ 掌握跨服务调用下的数据一致性初步处理  
+ 理解“预占库存”与“实际扣减”的区别  
+ 实践订单状态机初始设计（PENDING → PAID）

**业务/技术注意点**：  

+ 下单前需重新校验商品价格与库存（防止购物车期间商品变更）  
+ 预占库存采用同步 Feign 调用，失败则整个下单回滚（本地事务）  
+ 订单号生成使用雪花算法（`IdGenerator` 放在 `common` 中）  
+ 订单创建后，清空用户购物车中已下单商品

---

## 场景 5：支付流程（模拟）
**业务流程**：  
选择支付方式 → 模拟支付 → 更新订单状态 → 实际扣减库存

**验收标准**：  

+ 支付成功后，订单状态更新为“已支付”  
+ 支付失败时，订单保持“待支付”状态  
+ 支付成功后，调用 `product-service` 实际扣减库存  
+ 支付金额与订单应付金额一致  
+ 支付记录（流水号、时间、状态）被持久化

**学习目标**：  

+ 理解支付状态与订单状态的联动机制  
+ 掌握幂等性设计（同一订单多次支付请求只处理一次）  
+ 实践最终一致性思想（支付成功才扣库存）

**业务/技术注意点**：  

+ 支付接口为模拟：`POST /pay?orderId=123&success=true`  
+ 支付前校验订单是否存在、状态是否为“待支付”  
+ 支付成功后，才调用 `product-service` 执行**实际库存扣减**  
+ 支付记录表需包含 `order_id`、`amount`、`status`、`pay_time` 等字段  
+ 同一订单多次支付请求需幂等（可通过订单状态或支付流水号去重）

---

## 场景 6：订单查询与管理
**业务流程**：  
查看我的订单列表 → 查看订单详情 → 取消订单 → 追踪订单状态

**验收标准**：  

+ 用户只能查询自己的订单（基于 JWT 中的用户 ID）  
+ 订单列表支持分页  
+ 订单详情包含商品、价格、状态、时间等完整信息  
+ 取消“待支付”订单时，释放预占库存  
+ 订单状态流转符合业务规则（如：待支付 → 已支付 → 已发货）

**学习目标**：  

+ 验证整个交易链路的可追溯性与数据一致性  
+ 掌握基于用户上下文的数据隔离（Row-Level Security 简化版）  
+ 理解状态变更对库存的影响（取消订单需回滚预占）

**业务/技术注意点**：  

+ 查询订单时必须校验 `user_id = 当前用户 ID`，防止越权  
+ 仅允许取消“待支付”状态的订单  
+ 取消订单时，调用 `product-service` 释放预占库存  
+ 订单状态变更需记录操作日志（可简化为更新 `update_time`）


